---
layout: post
title: "[ML] Machine Learning Toolkit"
date: 2023-07-11
categories: [ML]
tags: [ml]
---






## 도구모음(toolkit)에 대한 설명

- **NumPy**: NumPy는 파이썬에서 수치 연산을 위한 핵심 라이브러리. 다차원 배열 객체와 함께 수학적인 함수와 연산을 제공하여 효율적인 수치 계산을 가능하게 하고, 대규모 데이터 집합을 다룰 수 있는 기능을 제공하며, 선형 대수, 푸리에 변환, 난수 생성 등 다양한 수학적 연산을 지원.

- **SciPy**: SciPy는 과학 및 공학 계산을 위한 파이썬 라이브러리. 다양한 수치 알고리즘과 기능을 포함하고 있어, 최적화, 선형 대수, 통계 분석, 신호 처리, 이미지 처리, 특수 함수 등 다양한 과학적 계산 작업에 사용되고, NumPy와 함께 사용되며, 고급 수학적 기능과 최적화 알고리즘 등을 제공.

- **Matplotlib**: Matplotlib은 파이썬의 데이터 시각화를 위한 라이브러리. 다양한 그래프와 플롯 스타일을 지원하며, 선 그래프, 막대 그래프, 산점도, 히스토그램 등 다양한 종류의 그래프를 생성할 수 있, 데이터의 시각적 탐색과 분석, 결과의 시각화, 보고서 및 발표 자료 작성 등에  사용됨.

- **Scikit-Learn (sklearn)**: Scikit-Learn은 파이썬에서 기계 학습과 데이터 마이닝을 위한 라이브러리. 다양한 기계 학습 알고리즘과 도구를 제공하여 데이터의 분류, 회귀, 군집화, 차원 축소 등 다양한 작업을 수행할 수 있음. 사용하기 쉬운 API와 다양한 기능을 제공하여 머신 러닝 모델의 구축과 평가, 데이터 전처리 등을 지원



### 데이터 형식

*부호 있는 정수와 부호 없는 정수가 나누어지는 이유: 데이터를 표현하는 방식에서 차이가 있기 때문*
1. **부호 있는 정수** (Signed Integers):
    - 부호 있는 정수는 양수, 음수, 0을 표현할 수 있습니다.
    - 값의 범위는 음수에서 양수까지입니다.
    - 정수 값 앞에 부호 비트를 가지고 있어서 양수와 음수를 구별합니다.
    - 예를 들어, -10, -5, 0, 10과 같은 값들이 부호 있는 정수로 표현됩니다.
    - C 언어에서는 int, long, short 등이 부호 있는 정수 데이터 타입입니다.
2. **부호 없는 정수** (Unsigned Integers):
    - 부호 없는 정수는 음수를 표현할 수 없고, 0과 양수만을 표현할 수 있습니다.
    - 값의 범위는 0에서 양수까지입니다.
    - 부호 비트가 없기 때문에 값의 범위가 더 크게 표현됩니다.
    - 예를 들어, 0, 5, 10, 100과 같은 값들이 부호 없는 정수로 표현됩니다.
    - C 언어에서는 unsigned int, unsigned long, unsigned short 등이 부호 없는 정수 데이터 타입입니다.

부호 있는 정수와 부호 없는 정수는 각각 다른 용도와 제약 사항을 가지고 있습니다. 예를 들어, 부호 있는 정수는 양수와 음수를 모두 표현할 수 있어서 범위가 더 작지만 음수 값을 다룰 때 유용합니다. 반면에 부호 없는 정수는 양수만을 표현할 수 있지만 범위가 더 크기 때문에 값을 저장하고 비트 연산을 수행하는 등의 용도로 유용합니다.

- **C 데이터 형식**
    1. *bool*:
        - C 형식: **`_Bool`**
        - 값 범위: True 또는 False로 표현하는 불리언 값
    2. **int8, uint8**:
        - C 형식: **`signed char`** (int8), **`unsigned char`** (uint8)
        - 값 범위: -128에서 127 (int8), 0에서 255 (uint8)
    3. **int16, uint16**:
        - C 형식: **`short`** (int16), **`unsigned short`** (uint16)
        - 값 범위: -32,768에서 32,767 (int16), 0에서 65,535 (uint16)
    4. **int32, uint32**:
        - C 형식: **`int`** (int32), **`unsigned int`** (uint32)
        - 값 범위: -2,147,483,648에서 2,147,483,647 (int32), 0에서 4,294,967,295 (uint32)
    5. **int64, uint64**:
        - C 형식: **`long long`** (int64), **`unsigned long long`** (uint64)
        - 값 범위: -9,223,372,036,854,775,808에서 9,223,372,036,854,775,807 (int64), 0에서 18,446,744,073,709,551,615 (uint64)
    6. **float16**:
        - C 형식: **`__fp16`** (C11부터 지원)
        - 값 범위: 반정밀도 부동 소수점 수
    7. **float32**:
        - C 형식: **`float`**
        - 값 범위: 단정밀도 부동 소수점 수
    8. **float64**:
        - C 형식: **`double`**
        - 값 범위: 배정밀도 부동 소수점 수

    
### 반정밀도, 단정밀도, 배정밀도?
    반정밀도 부동 소수점은 메모리 사용을 줄이는 데에는 도움이 될 수 있지만, 값을 표현하는 정밀도가 낮기 때문에 
    연산 과정에서 정확도 손실이 발생할 수 있습니다. 따라서, 반정밀도 부동 소수점은 특수한 상황이나 특정한 계산 
    요구 사항에 맞게 사용되는 경우가 있을 수 있지만, 대부분의 상황에서는 단정밀도(float32) 또는 
    배정밀도(float64)를 사용하는 것이 일반적입니다.

    예를 들어, 반정밀도 부동 소수점은 신경망과 같은 딥러닝 모델의 가중치(W)를 표현하는 데에 활용될 수 있습니다. 
    대부분의 딥러닝 프레임워크는 단정밀도(float32)를 기본으로 사용하지만, 메모리 사용을 줄이기 위해 
    반정밀도(float16)를 선택할 수도 있습니다.

    딥러닝 모델의 가중치는 학습 과정에서 업데이트되기 때문에 정밀도 손실이 발생해도 크게 문제되지 않습니다. 
    또한, 반정밀도 부동 소수점은 메모리 사용을 크게 줄일 수 있어서 모델의 크기를 줄이고 처리 속도를 향상시킬 
    수 있습니다.

    하지만 반정밀도 부동 소수점을 사용하는 경우 정확도 손실이 발생할 수 있으므로, 주의해야 합니다. 
    특히, 학습 과정에서 가중치 업데이트에 따른 오차가 누적되어 모델의 성능에 영향을 줄 수 있습니다. 
    따라서, 정확도가 매우 중요한 작업이나 민감한 계산에는 단정밀도(float32) 또는 배정밀도(float64)를 
    사용하는 것이 좋습니다.

    결론적으로, 반정밀도 부동 소수점은 메모리 사용을 줄이는 데에는 유용하지만, 값의 정확도가 낮아 
    연산 과정에서 정확도 손실이 발생할 수 있습니다. 따라서, 사용 시에는 주의하여 특정한 상황과 계산 요구 사항에 
    맞게 선택해야 합니다.
